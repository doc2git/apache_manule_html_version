<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<meta name="keywords" content="Apache, 中文, 手册, 中文版, 中文手册, 中文版手册, 参考手册, 中文参考手册, 金步国" />
<meta name="description" content="Apache 2.2 中文版参考手册" />
<meta name="author" content="金步国" />
<link href="../style/css/manual-zip.css" rel="stylesheet" media="all" type="text/css" title="Main stylesheet" />
<link href="../style/css/manual-zip-100pc.css" rel="alternate stylesheet" media="all" type="text/css" title="No Sidebar - Default font size" />
<link href="../style/css/manual-print.css" rel="stylesheet" media="print" type="text/css" />
<title>URL重写指南 － Apache 2.2 中文版参考手册</title>
</head>
<body id="manual-page"><div id="page-header">
<p class="menu"><a href="../mod/index.html">模块索引</a> | <a href="../mod/directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p><p class="apache">Apache HTTP Server 版本2.2</p><img alt="" src="../images/feather.gif" /></div>
<div class="up"><a href="./index.html"><img title="&lt;-" alt="&lt;-" src="../images/left.gif" /></a></div>
<div id="path"><a href="http://www.apache.org/">Apache</a> &gt; <a href="http://httpd.apache.org/">HTTP Server</a> &gt; <a href="http://httpd.apache.org/docs/">文档</a> &gt; <a href="../index.html">版本2.2</a> &gt; <a href="./index.html">杂项文档</a></div>

<div id="translation-info">　　 <a href="../translator_announcement.html#thanks">致谢</a> | <a href="../translator_announcement.html#announcement">译者声明</a> | 本篇译者：<a href="mailto:&#099;sfr&#0097;nk&#0064;&#099;itiz&#046;n&#0101;t">金步国</a> | 本篇译稿最后更新：2006年1月11日 | <a href="../translator_announcement.html#last_new">获取最新版本</a></div>
<div id="page-content"><div id="preamble"><h1>URL重写指南</h1>


    <div class="note">
      <p>Originally written by<br />
      <cite>Ralf S. Engelschall &lt;rse@apache.org&gt;</cite><br />
      December 1997</p>
    </div>

    <p>本文是<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>的<a href="../mod/mod_rewrite.html">参考文档</a>，阐述在实际应用中如何解决网管所面临的基于URL的典型问题，并详细描述了如何配置URL重写规则集以解决问题。</p>

  </div>
  <div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="ToC1" id="ToC1"><code>mod_rewrite</code>简介</a></h2>

    

    <p>Apache的<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>是提供了强大URL操作的杀手级的模块，可以实现几乎所有你梦想的URL操作类型，其代价是你必须接受其复杂性，因为<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>的主要障碍就是初学者不容易理解和运用，即使是Apache专家有时也会发掘出<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>的新用途。换句话说：对于<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>，或者是打退堂鼓永不再用，或者是喜欢它并一生受用。本文试图通过对已有方案的表述来创造一个成功的开端，以免你放弃。</p>

  </div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="ToC2" id="ToC2">实践方案</a></h2>

    

    <p>我自己创造和收集了许多实践方案，不要有畏惧心理，从这些例子开始学习URL重写的黑匣子吧。</p>

    <div class="warning">注意：根据你的服务器配置，可能有必要对例子作些微修改，比如，新启用<code class="module"><a href="../mod/mod_alias.html">mod_alias</a></code>和<code class="module"><a href="../mod/mod_userdir.html">mod_userdir</a></code>时要增加[PT]标志，或者重写.htaccess而不是单个服务器中的规则集。对一个特定的规则集应该先透彻理解然后再考虑应用，这样才能避免出现问题。</div>

  </div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="url" id="url">URL 的规划</a></h2>

    

    <h3>规范的URL</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>在有些web服务器上，一个资源会拥有多个URL，在实际应用和发布中应该被使用的是规范的URL，其他的则是简写或者只在内部使用。无论用户在请求中使用什么形式的URL，他最终看见的都应该是规范的URL。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>对所有不规范的URL执行一个外部HTTP重定向，以改变它在浏览器地址栏中的显示及其后继请求。下例中的规则集用规范的/u/user替换/~user，并修正了/u/user所遗漏的后缀斜杠。</p>

			<div class="example"><pre>
RewriteRule   ^/<strong>~</strong>([^/]+)/?(.*)    /<strong>u</strong>/$1/$2  [<strong>R</strong>]
RewriteRule   ^/([uge])/(<strong>[^/]+</strong>)$  /$1/$2<strong>/</strong>   [<strong>R</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>规范的主机名</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>这个规则的目的是强制使用特定的主机名以代替其他名字。比如，你想强制使用<strong>www.example.com</strong>代替<strong>example.com</strong>，就可以在以下方法的基础上进行修改：</dd>

        <dt>方案：</dt>

        <dd>
<div class="example"><pre>
# 针对运行在非80端口的站点
RewriteCond %{HTTP_HOST}   !^fully\.qualified\.domain\.name [NC]
RewriteCond %{HTTP_HOST}   !^$
RewriteCond %{SERVER_PORT} !^80$
RewriteRule ^/(.*)         http://fully.qualified.domain.name:%{SERVER_PORT}/$1 [L,R]

# 对一个运行在80端口的站点
RewriteCond %{HTTP_HOST}   !^fully\.qualified\.domain\.name [NC]
RewriteCond %{HTTP_HOST}   !^$
RewriteRule ^/(.*)         http://fully.qualified.domain.name/$1 [L,R]
</pre></div>
        </dd>
      </dl>

    

    <h3>移动过的<code>DocumentRoot</code></h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>通常，web服务器的<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>直接对应于URL&quot;/&quot;，但是，它常常不是处于最高一级，而可能只是众多数据池中的一个实体。比如，在Intranet站点中，有/e/www/(WWW的主页)、/e/sww/(Intranet的主页)等等，而<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>指向了/e/www/，则必须保证此数据池中所有内嵌的图片和其他元素对后继请求有效。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>只须重定向URL&quot;/&quot;到&quot;/e/www/&quot;即可。这个方案看起来很简单，但只是因为有了mod_rewrite模块的支持，它才简单，因为传统的URL Aliases机制(由mod_alias及其相关模块提供)只是作了一个前缀匹配，DocumentRoot是一个对所有URL的前缀，因而无法实现这样的重定向。而用mod_rewrite的确很简单：</p>
         
			<div class="example"><pre>
RewriteEngine on
RewriteRule   <strong>^/$</strong>  /e/www/  [<strong>R</strong>]
</pre></div>

    <p>注意， 也可以通过<code class="directive"><a href="../mod/mod_alias.html#redirectmatch">RedirectMatch</a></code>指令达到这个目的：</p>

    <div class="example"><p><code>
    RedirectMatch ^/$ http://example.com/e/www/
    </code></p></div>
        </dd>
      </dl>

    

    <h3>后缀斜杠的问题</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>每个网管对引用目录后缀斜杠的问题都有一本苦经，如果遗漏了，服务器会产生一个错误，因为如果请求是/~quux/foo而不是/~quux/foo/ ，服务器就会去找一个叫foo的文件，而它是一个目录，所以就报错了。事实上，大多数情况下，它自己会试图修正这个错误，但是有时候需要你手工纠正，比如，在重写了许多CGI脚本中的复杂的URL以后。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>解决这个微妙问题的方案是让服务器自动添加后缀斜杠。对此，必须使用一个外部重定向，使浏览器正确地处理后继的对诸如图片的请求。如果仅仅作一个内部重写，可能只对目录页面有效，而对内嵌有使用相对URL的图片的页面无效，因为浏览器有请求内嵌目标的可能。比如，如果不用外部重定向，/~quux/foo/index.html页面中对image.gif的请求，其结果将是/~quux/image.gif</p>

          <p>所以，应该这样写：</p>

<div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^foo<strong>$</strong>  foo<strong>/</strong>  [<strong>R</strong>]
</pre></div>

          <p>又懒又疯狂的做法是把这些写入其宿主目录中的顶级.htaccess中，但是须注意，如此会带来一些处理上的开销。</p>

<div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteCond    %{REQUEST_FILENAME}  <strong>-d</strong>
RewriteRule    ^(.+<strong>[^/]</strong>)$           $1<strong>/</strong>  [R]
</pre></div>
        </dd>
      </dl>

    

    <h3>集群网站的同类URL规划</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>我们希望在一个Intranet集群网站中，对所有WWW服务器建立一致的URL规划，也就是说，所有的URL(针对每个服务器进行本地配置，因此是独立于各个服务器的)实际上都是独立于各个服务器的！我们需要的是一个具有独立于各个服务器的一致性规划的WWW名称空间，即URL不需要包含物理目标服务器，而由集群本身来自动定位物理目标主机。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>首先，目标服务器的信息来自(产生)于包含有用户、组以及实体的外部地图，其格式形如：</p>

<div class="example"><pre>
user1  server_of_user1
user2  server_of_user2
:      :
</pre></div>

          <p>这些信息被存入map.xxx-to-host文件。其次，如果URL在一个服务器上无效，需要引导所有的服务器重定向URL</p>

<div class="example"><pre>
/u/user/anypath
/g/group/anypath
/e/entity/anypath
</pre></div>

          <p>到</p>

<div class="example"><pre>
http://physical-host/u/user/anypath
http://physical-host/g/group/anypath
http://physical-host/e/entity/anypath
</pre></div>

          <p>以下规则集依靠映射文件来完成这个操作(假定，如果一个用户在映射中没有对应的项，则使用server0为默认服务器)：</p>

<div class="example"><pre>
RewriteEngine on

RewriteMap      user-to-host   txt:/path/to/map.user-to-host
RewriteMap     group-to-host   txt:/path/to/map.group-to-host
RewriteMap    entity-to-host   txt:/path/to/map.entity-to-host

RewriteRule   ^/u/<strong>([^/]+)</strong>/?(.*)   http://<strong>${user-to-host:$1|server0}</strong>/u/$1/$2
RewriteRule   ^/g/<strong>([^/]+)</strong>/?(.*)  http://<strong>${group-to-host:$1|server0}</strong>/g/$1/$2
RewriteRule   ^/e/<strong>([^/]+)</strong>/?(.*) http://<strong>${entity-to-host:$1|server0}</strong>/e/$1/$2

RewriteRule   ^/([uge])/([^/]+)/?$          /$1/$2/.www/
RewriteRule   ^/([uge])/([^/]+)/([^.]+.+)   /$1/$2/.www/$3\
</pre></div>
        </dd>
      </dl>

    

    <h3>移动用户主目录到不同的web服务器</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>通常，许多网管在建立一个新的web服务器时，都会有这样的要求：重定向一个web服务器上的所有用户主目录到另一个web服务器。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>很简单，在老的web服务器上重定向所有的URL&quot;/~user/anypath&quot;到http://newserver/~user/anypath</p>

<div class="example"><pre>
RewriteEngine on
RewriteRule   ^/~(.+)  http://<strong>newserver</strong>/~$1  [R,L]
</pre></div>
        </dd>
      </dl>

    

    <h3>结构化的用户主目录</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>一些拥有几千个用户的网站通常都使用结构化的用户主目录规划，即每个用户主目录位于一个带有特定前缀，比如其用户名的第一个字符的子目录下：/~foo/anypath代表/home/<strong>f</strong>/foo/.www/anypath，而/~bar/anypath代表/home/<strong>b</strong>/bar/.www/anypath</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>可以使用下列规则集来扩展~以达到上述目的。</p>

<div class="example"><pre>
RewriteEngine on
RewriteRule   ^/~(<strong>([a-z])</strong>[a-z0-9]+)(.*)  /home/<strong>$2</strong>/$1/.www$3
</pre></div>
        </dd>
      </dl>

    

    <h3>文件系统的重组</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>这是一个不加雕琢的例子：一个大量使用针对目录的规则集以实现平滑的观感，并且从来不用调整数据结构的杀手级的应用。背景：net.sw从1992年开始，存放了我收集的免费Unix软件包。它是我的爱好也是我的工作，因为在学习计算机科学的同时，业余时间还做了多年的系统和网络管理员。每周我都需要整理软件，因而建立了一个层次很深的目录结构来存放各种软件包：</p>

			<div class="example"><pre>
drwxrwxr-x   2 netsw  users    512 Aug  3 18:39 Audio/
drwxrwxr-x   2 netsw  users    512 Jul  9 14:37 Benchmark/
drwxrwxr-x  12 netsw  users    512 Jul  9 00:34 Crypto/
drwxrwxr-x   5 netsw  users    512 Jul  9 00:41 Database/
drwxrwxr-x   4 netsw  users    512 Jul 30 19:25 Dicts/
drwxrwxr-x  10 netsw  users    512 Jul  9 01:54 Graphic/
drwxrwxr-x   5 netsw  users    512 Jul  9 01:58 Hackers/
drwxrwxr-x   8 netsw  users    512 Jul  9 03:19 InfoSys/
drwxrwxr-x   3 netsw  users    512 Jul  9 03:21 Math/
drwxrwxr-x   3 netsw  users    512 Jul  9 03:24 Misc/
drwxrwxr-x   9 netsw  users    512 Aug  1 16:33 Network/
drwxrwxr-x   2 netsw  users    512 Jul  9 05:53 Office/
drwxrwxr-x   7 netsw  users    512 Jul  9 09:24 SoftEng/
drwxrwxr-x   7 netsw  users    512 Jul  9 12:17 System/
drwxrwxr-x  12 netsw  users    512 Aug  3 20:15 Typesetting/
drwxrwxr-x  10 netsw  users    512 Jul  9 14:08 X11/
</pre></div>

          <p>1996年7月，我决定通过一个漂亮的Web接口公开我的收藏。&quot;漂亮&quot;是指提供一个接口以直接浏览整个目录结构，同时不对这个结构做任何改变，甚至也不在结构顶部放置CGI脚本。为什么呢？因为这个结构还要能够被FTP访问，而且我不希望其中有任何Web或者CGI成分。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>这个方案分为两个部分：第一个部分，是用于在空闲时间建立所有目录页面的CGI脚本集。我把它们放在/e/netsw/.www/，如下：</p>

<div class="example"><pre>
-rw-r--r--   1 netsw  users    1318 Aug  1 18:10 .wwwacl
drwxr-xr-x  18 netsw  users     512 Aug  5 15:51 DATA/
-rw-rw-rw-   1 netsw  users  372982 Aug  5 16:35 LOGFILE
-rw-r--r--   1 netsw  users     659 Aug  4 09:27 TODO
-rw-r--r--   1 netsw  users    5697 Aug  1 18:01 netsw-about.html
-rwxr-xr-x   1 netsw  users     579 Aug  2 10:33 netsw-access.pl
-rwxr-xr-x   1 netsw  users    1532 Aug  1 17:35 netsw-changes.cgi
-rwxr-xr-x   1 netsw  users    2866 Aug  5 14:49 netsw-home.cgi
drwxr-xr-x   2 netsw  users     512 Jul  8 23:47 netsw-img/
-rwxr-xr-x   1 netsw  users   24050 Aug  5 15:49 netsw-lsdir.cgi
-rwxr-xr-x   1 netsw  users    1589 Aug  3 18:43 netsw-search.cgi
-rwxr-xr-x   1 netsw  users    1885 Aug  1 17:41 netsw-tree.cgi
-rw-r--r--   1 netsw  users     234 Jul 30 16:35 netsw-unlimit.lst
</pre></div>

          <p>其中的&quot;DATA&quot;子目录包含了上述目录结构，即实在的net.sw ，由rdist在需要的时候自动更新。第二个部分的遗留问题是：如何连接这两个结构为一个平滑观感的URL树？我希望在运行适当的CGI脚本而使用各种URL的时候，使用户感觉不到&quot;DATA&quot;目录的存在。方案如下：首先，我把下列配置放在服务器上DocumentRoot中针对目录的配置文件里，重写公布的URL&quot;/net.sw/&quot;为内部路径&quot;/e/netsw&quot; ：</p>

			<div class="example"><pre>
RewriteRule  ^net.sw$       net.sw/        [R]
RewriteRule  ^net.sw/(.*)$  e/netsw/$1
</pre></div>

          <p>第一条规则是针对遗漏后缀斜杠的请求的！第二条规则才是真正实现功能的。接着，就是放在针对目录的配置文件/e/netsw/.www/.wwwacl中的杀手级的配置了：</p>

<div class="example">
  <pre>
Options       ExecCGI FollowSymLinks Includes MultiViews

RewriteEngine on

# 我们通过"/net.sw/"前缀到达
RewriteBase   /net.sw/

# 首先重写根目录到cgi处理脚本
RewriteRule   ^$                       netsw-home.cgi     [L]
RewriteRule   ^index\.html$            netsw-home.cgi     [L]

#  当浏览器请求perdir页面时剥去子目录
RewriteRule   ^.+/(netsw-[^/]+/.+)$    $1                 [L]

# 现在打断本地文件的重写
RewriteRule   ^netsw-home\.cgi.*       -                  [L]
RewriteRule   ^netsw-changes\.cgi.*    -                  [L]
RewriteRule   ^netsw-search\.cgi.*     -                  [L]
RewriteRule   ^netsw-tree\.cgi$        -                  [L]
RewriteRule   ^netsw-about\.html$      -                  [L]
RewriteRule   ^netsw-img/.*$           -                  [L]

# 任何别的东西都是一个由另一个cgi脚本处理的子目录
RewriteRule   !^netsw-lsdir\.cgi.*     -                  [C]
RewriteRule   (.*)                     netsw-lsdir.cgi/$1
</pre>
</div>

          <p>阅读提示：</p>

          <ol>
            <li>注意前半部分中的标志L(最后)，和无对应项(&quot;-&quot;)</li>

            <li>注意后半部分中的符号!(非)，和标志C(链)</li>

            <li>注意最后一条规则的全匹配模式</li>
          </ol>
        </dd>
      </dl>

    

    <h3>NCSA图像映射和<code>mod_imap</code></h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>许多人都希望在从NCSA web服务器向较现代的Apache web服务器转移中实现平滑过渡，即希望老的NCSA图像映射程序能在Apache的较现代的<code class="module"><a href="../mod/mod_imap.html">mod_imap</a></code>支持下正常运作。但问题在于，到处都是通过/cgi-bin/imagemap/path/to/page.map引用imagemap程序的连接，而在Apache下，应该写成/path/to/page.map</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>使用全局规则在传输过程中去除所有这些请求的前缀：</p>

<div class="example"><pre>
RewriteEngine  on
RewriteRule    ^/cgi-bin/imagemap(.*)  $1  [PT]
</pre></div>
        </dd>
      </dl>

    

    <h3>在多个目录中搜索页面</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>有时会有必要使web服务器在多个目录中搜索页面，对此，MultiViews或者其他技术无能为力。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>编制一个明确的规则集以搜索目录中的文件。</p>

<div class="example"><pre>
RewriteEngine on

# 首先尝试在 custom/...中寻找
RewriteCond         /your/docroot/<strong>dir1</strong>/%{REQUEST_FILENAME}  -f
RewriteRule  ^(.+)  /your/docroot/<strong>dir1</strong>/$1  [L]

# 然后尝试在 pub/...中寻找
RewriteCond         /your/docroot/<strong>dir2</strong>/%{REQUEST_FILENAME}  -f
RewriteRule  ^(.+)  /your/docroot/<strong>dir2</strong>/$1  [L]

# 再找不到就继续寻找其他的Alias 或 ScriptAlias 目录...
RewriteRule   ^(.+)  -  [PT]
</pre></div>
        </dd>
      </dl>

    

    <h3>按照URL的片段设置环境变量</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>如果希望保持请求之间的状态信息，又不希望使用CGI来包装所有页面，而是只通过分离URL中的有用信息来编码。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>可以用一个规则集来分离出状态信息，并设置环境变量以备此后用于XSSI或CGI 。这样，一个&quot;/foo/S=java/bar/&quot;的URL会被解析为/foo/bar/ ，而环境变量STATUS则被设置为&quot;java&quot;。</p>

			<div class="example"><pre>
RewriteEngine on
RewriteRule   ^(.*)/<strong>S=([^/]+)</strong>/(.*)    $1/$3 [E=<strong>STATUS:$2</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>虚拟用户主机</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>如果需要为用户<strong>username</strong>支持一个www.<strong>username</strong>.host.domain.com的主页，但不是用在此机器上建虚拟主机的方法，而是用仅在此机器上增加一个DNS记录的方法实现。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>对HTTP/1.0的请求，这是无法实现的；但是对HTTP/1.1的在HTTP头中包含有主机名的请求，可以用以下规则集来内部地重写http://www.username.host.com/anypath为/home/username/anypath</p>

<div class="example"><pre>
RewriteEngine on
RewriteCond   %{<strong>HTTP_HOST</strong>}                 ^www\.<strong>[^.]+</strong>\.host\.com$
RewriteRule   ^(.+)                        %{HTTP_HOST}$1          [C]
RewriteRule   ^www\.<strong>([^.]+)</strong>\.host\.com(.*) /home/<strong>$1</strong>$2
</pre></div>
        </dd>
      </dl>

    

    <h3>为外来访问者重定向用户主目录</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>对不是来自本地域ourdomain.com的外来访问者的请求，重定向其用户主目录URL到另一个web服务器www.somewhere.com ，有时这种做法也会用在虚拟主机的配置段中。</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>只须一个重写条件：</p>

<div class="example"><pre>
RewriteEngine on
RewriteCond   %{REMOTE_HOST}  <strong>!^.+\.ourdomain\.com$</strong>
RewriteRule   ^(/~.+)         http://www.somewhere.com/$1 [R,L]
</pre></div>
        </dd>
      </dl>

    

    <h3>重定向失败的URL到其他web服务器</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>如何重写URL以重定向对web服务器A的失败请求到服务器B，是一个常见的问题。一般，可以用Perl写的CGI脚本通过<code class="directive"><a href="../mod/core.html#errordocument">ErrorDocument</a></code>来解决，此外，还有<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>方案。但是须注意，这种方法的执行效率不如用<code class="directive"><a href="../mod/core.html#errordocument">ErrorDocument</a></code>的CGI脚本!</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>第一种方案，有最好的性能而灵活性欠佳，出错概率小所以安全：</p>

<div class="example"><pre>
RewriteEngine on
RewriteCond   /your/docroot/%{REQUEST_FILENAME} <strong>!-f</strong>
RewriteRule   ^(.+)                             http://<strong>webserverB</strong>.dom/$1
</pre></div>

          <p>但是其问题在于，它只对位于<code class="directive"><a href="../mod/core.html#documentroot">DocumentRoot</a></code>中的页面有效。虽然可以增加更多的条件(比如同时还处理用户主目录，等等)，但是还有一个更好的方法：</p>

<div class="example"><pre>
RewriteEngine on
RewriteCond   %{REQUEST_URI} <strong>!-U</strong>
RewriteRule   ^(.+)          http://<strong>webserverB</strong>.dom/$1
</pre></div>

          <p>这种方法使用了<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>提供的&quot;向前参照&quot;(look-ahead)的功能，是一种对所有URL类型都有效而且安全的方法。但是，对web服务器的性能会有影响，所以如果web服务器有一个强大的CPU，那就用这个方法。而在慢速机器上，可以用第一种方法，或者用性能更好的<code class="directive"><a href="../mod/core.html#errordocument">ErrorDocument</a></code>CGI脚本。</p>
        </dd>
      </dl>

    

    <h3>扩展的重定向</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>有时候，我们会需要更多的对重定向URL的(有关字符转义机制方面的)控制。通常，Apache内核中的URL转义函数uri_escape()同时还会对锚(anchor)转义，即类似&quot;url#anchor&quot;的URL，因此，你不能用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>对此类URL直接重定向。那么如何实现呢?</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>必须用NPH-CGI脚本使它自己重定向，因为对NPH(无须解析的HTTP头)不会发生转义操作。首先，在针对服务器的配置中(应该位于所有重写规则的最后)，引入一种新的URL类型&quot;xredirect:&quot;：</p>

<div class="example"><pre>
RewriteRule ^xredirect:(.+) /path/to/nph-xredirect.cgi/$1 \
            [T=application/x-httpd-cgi,L]
</pre></div>

          <p>以强制所有带&quot;xredirect:&quot;前缀的URL被传送到如下的nph-xredirect.cgi程序：</p>

<div class="example"><pre>
#!/path/to/perl
##
##  nph-xredirect.cgi -- NPH/CGI script for extended redirects

##

$| = 1;
$url = $ENV{'PATH_INFO'};

print "HTTP/1.0 302 Moved Temporarily\n";
print "Server: $ENV{'SERVER_SOFTWARE'}\n";
print "Location: $url\n";
print "Content-type: text/html\n";
print "\n";
print "&lt;html&gt;\n";
print "&lt;head&gt;\n";
print "&lt;title&gt;302 Moved Temporarily (EXTENDED)&lt;/title&gt;\n";
print "&lt;/head&gt;\n";
print "&lt;body&gt;\n";
print "&lt;h1&gt;Moved Temporarily (EXTENDED)&lt;/h1&gt;\n";
print "The document has moved &lt;a HREF=\"$url\"&gt;here&lt;/a&gt;.&lt;p&gt;\n";
print "&lt;/body&gt;\n";
print "&lt;/html&gt;\n";

##EOF##
</pre></div>

          <p>这是一种可以重定向所有URL类型的方法，包括不被<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>直接支持的类型。所以，还可以这样重定向&quot;news:newsgroup&quot;：</p>

<div class="example"><pre>
RewriteRule ^anyurl  xredirect:news:newsgroup
</pre></div>

          <div class="note">注意：无须对上述规则加[R]或[R,L]，因为&quot;xredirect:&quot;需要在稍后被其特殊的&quot;管道传送&quot;规则扩展。</div>
        </dd>
      </dl>

    

    <h3>文档访问的多路复用</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>你知道<a href="http://www.perl.com/CPAN">http://www.perl.com/CPAN</a>的CPAN(综合Perl存档网络)？它实现了一个重定向以提供全世界的CPAN镜像中离访问者最近的一个FTP站点，也可以称之为FTP访问多路复用服务。CPAN是通过CGI脚本实现的，那么用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>如何实现呢？</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>首先，我们注意到<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>从3.0.0版本开始，还可以重写&quot;ftp:&quot;类型。其次，对客户端顶级域名的路径最近的求取可以用<code class="directive"><a href="../mod/mod_rewrite.html#rewritemap">RewriteMap</a></code>实现。利用链式规则集，并用顶级域名作为查找多路复用地图的键，可以这样做：</p>

<div class="example"><pre>
RewriteEngine on
RewriteMap    multiplex                txt:/path/to/map.cxan
RewriteRule   ^/CxAN/(.*)              %{REMOTE_HOST}::$1                 [C]
RewriteRule   ^.+\.<strong>([a-zA-Z]+)</strong>::(.*)$  ${multiplex:<strong>$1</strong>|ftp.default.dom}$2  [R,L]
</pre></div>

<div class="example"><pre>
##
##  map.cxan -- Multiplexing Map for CxAN
##

de        ftp://ftp.cxan.de/CxAN/
uk        ftp://ftp.cxan.uk/CxAN/
com       ftp://ftp.cxan.com/CxAN/
 :
##EOF##
</pre></div>
        </dd>
      </dl>

    

    <h3>依赖于时间的重写</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>在页面内容按时间不同而变化的场合，比如重定向特定页面，许多网管仍然采用CGI脚本的方法，如何用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>来实现呢？</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>有许多类似TIME_xxx的变量可以用在重写条件中，利用&quot;&lt;STRING&quot;, &quot; &gt;STRING&quot;和&quot;=STRING&quot;的类型比较，并加以连接，就可以实现依赖于时间的重写：</p>

			<div class="example"><pre>
RewriteEngine on
RewriteCond   %{TIME_HOUR}%{TIME_MIN} &gt;0700
RewriteCond   %{TIME_HOUR}%{TIME_MIN} &lt;1900
RewriteRule   ^foo\.html$             foo.day.html
RewriteRule   ^foo\.html$             foo.night.html
</pre></div>

          <p>此例使URLfoo.html在07:00-19:00时指向foo.day.html ，而在其余时间，则指向foo.night.html ，对主页是一个不错的功能...</p>
        </dd>
      </dl>

    

    <h3>对YYYY过渡为XXXX的向前兼容</h3>

      

      <dl>
        <dt>说明：</dt>

        <dd>
          <p>在转变了大批.html文件为.phtml ，使文档.YYYY过渡成为文档.XXXX后，如何保持URL的向前兼容(仍然虚拟地存在)？</p>
        </dd>

        <dt>方案：</dt>

        <dd>
          <p>只须按基准文件名重写，并测试带有新的扩展名的文件是否存在，如果存在，则用新的，否则，仍然用原来的。</p>


<div class="example"><pre>
#   backward compatibility ruleset for
#   rewriting document.html to document.phtml
#   when and only when document.phtml exists
#   but no longer document.html
RewriteEngine on
RewriteBase   /~quux/
#   parse out basename, but remember the fact
RewriteRule   ^(.*)\.html$              $1      [C,E=WasHTML:yes]
#   rewrite to document.phtml if exists
RewriteCond   %{REQUEST_FILENAME}.phtml -f
RewriteRule   ^(.*)$ $1.phtml                   [S=1]
#   else reverse the previous basename cutout
RewriteCond   %{ENV:WasHTML}            ^yes$
RewriteRule   ^(.*)$ $1.html
</pre></div>
        </dd>
      </dl>

    

  </div><div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="content" id="content">内容的处理</a></h2>


    

    <h3>新旧URL(内部的)</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>假定已经把文件<code>bar.html</code>改名为<code>foo.html</code> ，需要对老的URL向前兼容，即让用户仍然可以使用老的URL，而感觉不到文件被改名了。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>通过以下规则内部地重写老的URL为新的：</p>

<div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^<strong>foo</strong>\.html$  <strong>bar</strong>.html
</pre></div>
        </dd>
      </dl>

    

    <h3>新旧URL(外部的)</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>仍然假定已经把文件<code>bar.html</code>改名为<code>foo.html</code> ，需要对老的URL向前兼容，但是要让用户得到文件被改名的暗示，即浏览器的地址栏中显示的是新的URL。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>作一个HTTP的强制重定向以改变浏览器和用户界面上的显示：</p>

<div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^<strong>foo</strong>\.html$  <strong>bar</strong>.html  [<strong>R</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>依赖于浏览器的内容</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>至少对重要的顶级页面，有时候有必要提供依赖于浏览器的最佳的内容，即对最新的Netscape提供最大化的版本，对Lynx提供最小化的版本，而对其他的浏览器则提供一个功能一般的版本。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>对此，内容协商无能为力，因为浏览器不提供那种形式的类型，所以只能在HTTP头"User-Agent"上想办法。以下规则集可以完成这个操作：如果HTTP头"User-Agent"以"Mozilla/3"开头，则页面<code>foo.html</code>被重写为<code>foo.NS.html</code> ，而后重写操作终止；如果是"Lynx"或者版本号为1和2的"Mozilla"，则重写为<code>foo.20.html</code> ；而其他所有的浏览器收到的页面则是<code>foo.32.html</code></p>

          <div class="example"><pre>
RewriteCond %{HTTP_USER_AGENT}  ^<strong>Mozilla/3</strong>.*
RewriteRule ^foo\.html$         foo.<strong>NS</strong>.html          [<strong>L</strong>]

RewriteCond %{HTTP_USER_AGENT}  ^<strong>Lynx/</strong>.*         [OR]
RewriteCond %{HTTP_USER_AGENT}  ^<strong>Mozilla/[12]</strong>.*
RewriteRule ^foo\.html$         foo.<strong>20</strong>.html          [<strong>L</strong>]

RewriteRule ^foo\.html$         foo.<strong>32</strong>.html          [<strong>L</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>动态镜像</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>假定，需要在我们的名称空间里加入其他远程主机的页面。对FTP服务器，可以用<code>mirror</code>程序以在本地机器上维持一个对远程数据的最新的拷贝；对web服务器，可以用类似的用于HTTP的<code>webcopy</code>程序。但这两种技术都有一个主要的缺点：此本地拷贝必须通过这个程序的执行来更新。所以，比较好的方法是，不采用静态镜像，而采用动态镜像，即在有数据请求时自动更新(远程主机上更新的数据)。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>为此，使用代理吞吐(<dfn>Proxy Throughput</dfn>)功能(flag <code>[P]</code>)，以映射远程页面甚至整个远程网络区域到我们的名称空间：</p>

          <div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^<strong>hotsheet/</strong>(.*)$  <strong>http://www.tstimpreso.com/hotsheet/</strong>$1  [<strong>P</strong>]
</pre></div>

<div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^<strong>usa-news\.html</strong>$   <strong>http://www.quux-corp.com/news/index.html</strong>  [<strong>P</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>反向动态镜像</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>...</dd>

        <dt>方案:</dt>

        <dd>
<div class="example"><pre>
RewriteEngine on
RewriteCond   /mirror/of/remotesite/$1           -U
RewriteRule   ^http://www\.remotesite\.com/(.*)$ /mirror/of/remotesite/$1
</pre></div>
        </dd>
      </dl>

    

    <h3>通过Intranet取得丢失的数据</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>这是一种在受防火墙保护的(内部)Intranet(<code>www2.quux-corp.dom</code>)上保存和维护实际数据，而虚拟地运行企业级(外部)Internet web服务器(<code>www.quux-corp.dom</code>)的巧妙的方法。这种方法是外部服务器在空闲时间从内部服务器取得被请求的数据。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>首先，必须确保防火墙对内部服务器的保护，并只允许此外部服务器取得数据。对包过滤(packet-filtering)防火墙，可以如下制定防火墙规则：</p>

<div class="example"><pre>
<strong>ALLOW</strong> Host www.quux-corp.dom Port &gt;1024 --&gt; Host www2.quux-corp.dom Port <strong>80</strong>

<strong>DENY</strong>  Host *                 Port *     --&gt; Host www2.quux-corp.dom Port <strong>80</strong>
</pre></div>

          <p>按你的实际配置，只要对上例稍作调整即可。接着，建立通过代理后台获取丢失数据的<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>规则：</p>

<div class="example"><pre>
RewriteRule ^/~([^/]+)/?(.*)          /home/$1/.www/$2
RewriteCond %{REQUEST_FILENAME}       <strong>!-f</strong>
RewriteCond %{REQUEST_FILENAME}       <strong>!-d</strong>
RewriteRule ^/home/([^/]+)/.www/?(.*) http://<strong>www2</strong>.quux-corp.dom/~$1/pub/$2 [<strong>P</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>负载的均衡</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>如何均衡<code>www.foo.com</code>的负载到<code>www[0-5].foo.com</code>(一共是6个服务器)?</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>这个问题有许多可能的解决方案，在此，我们讨论通称为“基于DNS”的方案，和特殊的使用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>的方案:</p>

          <ol>
            <li>
              <strong>DNS循环(DNS Round-Robin)</strong>

              <p>最简单的方法是用<code>BIND</code>的DNS循环特性，只要按惯例设置<code>www[0-9].foo.com</code>的DNS的A(地址)记录，如：</p>

<div class="example"><pre>
www0   IN  A       1.2.3.1
www1   IN  A       1.2.3.2
www2   IN  A       1.2.3.3
www3   IN  A       1.2.3.4
www4   IN  A       1.2.3.5
www5   IN  A       1.2.3.6
</pre></div>

              <p>然后，增加以下各项:</p>

<div class="example"><pre>
www    IN  CNAME   www0.foo.com.
       IN  CNAME   www1.foo.com.
       IN  CNAME   www2.foo.com.
       IN  CNAME   www3.foo.com.
       IN  CNAME   www4.foo.com.
       IN  CNAME   www5.foo.com.
       IN  CNAME   www6.foo.com.
</pre></div>

              <p>注意，上述看起来似乎是错误的，但事实上，它的确是<code>BIND</code>中的一个预期的特性，而且也可以这样用。无论如何，现在<code>www.foo.com</code>已经被解析，<code>BIND</code>可以给出<code>www0-www6</code> ，虽然每次在次序上会有轻微的置换/循环，客户端的请求可以被分散到各个服务器。但这并不是一个优秀的负载均衡方案，因为DNS解析信息可以被网络中其他名称服务器缓冲，而一旦<code>www.foo.com</code>被解析为<code>wwwN.foo.com</code>，则其后继请求都将被送往<code>www.foo.com</code>。但是最终结果是正确的，因为请求的总量的确被分散到各个服务器了</p>
            </li>

            <li>
              <strong>DNS 负载均衡</strong>

              <p>一种成熟的基于DNS的负载均衡方法是使用<a href="http://www.stanford.edu/~schemers/docs/lbnamed/lbnamed.html">http://www.stanford.edu/~schemers/docs/lbnamed/lbnamed.html</a>的<code>lbnamed</code>程序，它是一个Perl5程序，带有若干辅助工具，实现了真正的基于DNS的负载均衡。</p>
            </li>

            <li>
              <strong>代理吞吐循环(Proxy Throughput Round-Robin)</strong>

              <p>这是一个使用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>及其代理吞吐特性的方法。首先，在DNS记录中将<code>www0.foo.com</code>固定为<code>www.foo.com</code> ，如下：</p>

				<div class="example"><pre>
www    IN  CNAME   www0.foo.com.
</pre></div>

              <p>其次，将<code>www0.foo.com</code>转换为一个专职代理服务器，即由这个机器把所有到来的URL通过内部代理分散到另外5个服务器(<code>www1-www5</code>)。为此，必须建立一个规则集，对所有URL调用一个负载均衡脚本<code>lb.pl</code> 。</p>

				<div class="example"><pre>
RewriteEngine on
RewriteMap    lb      prg:/path/to/lb.pl
RewriteRule   ^/(.+)$ ${lb:$1}           [P,L]
</pre></div>

              <p>以下是<code>lb.pl</code> ：</p>

				<div class="example"><pre>
#!/path/to/perl
##
##  lb.pl -- load balancing script
##

$| = 1;

$name   = "www";     # the hostname base
$first  = 1;         # the first server (not 0 here, because 0 is myself)
$last   = 5;         # the last server in the round-robin
$domain = "foo.dom"; # the domainname

$cnt = 0;
while (&lt;STDIN&gt;) {
    $cnt = (($cnt+1) % ($last+1-$first));
    $server = sprintf("%s%d.%s", $name, $cnt+$first, $domain);
    print "http://$server/$_";
}

##EOF##
</pre></div>

              <div class="note">最后的说明：这样有用吗？<code>www0.foo.com</code>似乎也会超载呀？答案是：没错，它的确会超载，但是它超载的仅仅是简单的代理吞吐请求！所有诸如SSI、CGI、ePerl等等的处理完全是由其他机器完成的，这个才是要点。</div>
            </li>

            <li>
              <strong>硬件/TCP循环</strong>

              <p>还有一个硬件解决方案。Cisco有一个叫LocalDirector的东西，实现了TCP/IP层的负载均衡，事实上，它是一个位于网站集群前端的电路级网关。如果你有足够资金而且的确需要高性能的解决方案，那么可以用这个。</p>
            </li>
          </ol>
        </dd>
      </dl>

    

    <h3>反向代理</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>...</dd>

        <dt>方案:</dt>

        <dd>
<div class="example"><pre>
##
##  apache-rproxy.conf -- Apache configuration for Reverse Proxy Usage
##

#   server type
ServerType           standalone
Listen               8000
MinSpareServers      16
StartServers         16
MaxSpareServers      16
MaxClients           16
MaxRequestsPerChild  100

#   server operation parameters
KeepAlive            on
MaxKeepAliveRequests 100
KeepAliveTimeout     15
Timeout              400
IdentityCheck        off
HostnameLookups      off

#   paths to runtime files
PidFile              /path/to/apache-rproxy.pid
LockFile             /path/to/apache-rproxy.lock
ErrorLog             /path/to/apache-rproxy.elog
CustomLog            /path/to/apache-rproxy.dlog "%{%v/%T}t %h -&gt; %{SERVER}e URL: %U"

#   unused paths
ServerRoot           /tmp
DocumentRoot         /tmp
CacheRoot            /tmp
RewriteLog           /dev/null
TransferLog          /dev/null
TypesConfig          /dev/null
AccessConfig         /dev/null
ResourceConfig       /dev/null

#   speed up and secure processing
&lt;Directory /&gt;
Options -FollowSymLinks -SymLinksIfOwnerMatch
AllowOverride None

&lt;/Directory&gt;

#   the status page for monitoring the reverse proxy
&lt;Location /apache-rproxy-status&gt;
SetHandler server-status
&lt;/Location&gt;

#   enable the URL rewriting engine
RewriteEngine        on
RewriteLogLevel      0

#   define a rewriting map with value-lists where
#   mod_rewrite randomly chooses a particular value
RewriteMap     server  rnd:/path/to/apache-rproxy.conf-servers

#   make sure the status page is handled locally
#   and make sure no one uses our proxy except ourself
RewriteRule    ^/apache-rproxy-status.*  -  [L]
RewriteRule    ^(http|ftp)://.*          -  [F]

#   now choose the possible servers for particular URL types
RewriteRule    ^/(.*\.(cgi|shtml))$  to://${server:dynamic}/$1  [S=1]
RewriteRule    ^/(.*)$               to://${server:static}/$1

#   and delegate the generated URL by passing it
#   through the proxy module
RewriteRule    ^to://([^/]+)/(.*)    http://$1/$2   [E=SERVER:$1,P,L]

#   and make really sure all other stuff is forbidden
#   when it should survive the above rules...
RewriteRule    .*                    -              [F]

#   enable the Proxy module without caching
ProxyRequests        on
NoCache              *

#   setup URL reverse mapping for redirect reponses
ProxyPassReverse  /  http://www1.foo.dom/
ProxyPassReverse  /  http://www2.foo.dom/
ProxyPassReverse  /  http://www3.foo.dom/
ProxyPassReverse  /  http://www4.foo.dom/
ProxyPassReverse  /  http://www5.foo.dom/
ProxyPassReverse  /  http://www6.foo.dom/
</pre></div>

<div class="example"><pre>
##
##  apache-rproxy.conf-servers -- Apache/mod_rewrite selection table
##

#   list of backend servers which serve static
#   pages (HTML files and Images, etc.)
static    www1.foo.dom|www2.foo.dom|www3.foo.dom|www4.foo.dom

#   list of backend servers which serve dynamically
#   generated page (CGI programs or mod_perl scripts)
dynamic   www5.foo.dom|www6.foo.dom
</pre></div>
        </dd>
      </dl>

    

    <h3>新的MIME类型，新的服务</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>网上有许多很巧妙的CGI程序，但是用法晦涩，许多网管弃之不用。即使是Apache的MEME类型的动作处理器，也仅仅在CGI程序不需要在其输入中包含特殊URL(<code>PATH_INFO</code>和<code>QUERY_STRINGS</code>)时才很好用。首先，配置一种新的后缀为<code>.scgi</code>(安全CGI)文件类型，其处理器是很常见的<code>cgiwrap</code>程序。问题是：如果使用同类URL规划(见上述)，而用户宿主目录中的一个文件的URL是<code>/u/user/foo/bar.scgi</code> ，可是<code>cgiwrap</code>要求的URL的格式是<code>/~user/foo/bar.scgi/</code> ，以下规则解决了这个问题：</p>

          <div class="example"><pre>
RewriteRule ^/[uge]/<strong>([^/]+)</strong>/\.www/(.+)\.scgi(.*) ...
... /internal/cgi/user/cgiwrap/~<strong>$1</strong>/$2.scgi$3  [NS,<strong>T=application/x-http-cgi</strong>]
</pre></div>

          <p>另外，假设需要使用其他程序：<code>wwwlog</code>(显示<code>access.log</code>中的一个URL子树)和<code>wwwidx</code>(对一个URL子树运行Glimpse)，则必须对这些程序提供URL区域作为其操作对象。比如，对<code>/u/user/foo/</code>执行<code>swwidx</code>程序的超链是这样的：</p>

<div class="example"><pre>
/internal/cgi/user/swwidx?i=/u/user/foo/
</pre></div>

          <p>其缺点是，必须<strong>同时</strong>硬编码超链中的区域和CGI的路径，如果重组了这个区域，就需要花费大量时间来修改各个超链。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>方案是用一个特殊的新的URL格式，自动拼装CGI参数：</p>

<div class="example"><pre>
RewriteRule   ^/([uge])/([^/]+)(/?.*)/\*  /internal/cgi/user/wwwidx?i=/$1/$2$3/
RewriteRule   ^/([uge])/([^/]+)(/?.*):log /internal/cgi/user/wwwlog?f=/$1/$2$3
</pre></div>

          <p>现在，这个搜索到<code>/u/user/foo/</code>的超链简化成了：</p>

<div class="example"><pre>
HREF="*"
</pre></div>

          <p>它会被内部地自动转换为</p>

<div class="example"><pre>
/internal/cgi/user/wwwidx?i=/u/user/foo/
</pre></div>

          <p>如此，可以为使用&quot;<code>:log</code>&quot;的超链，拼装出调用CGI程序的参数。</p>
        </dd>
      </dl>

    

    <h3>从静态到动态</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>如何无缝转换静态页面<code>foo.html</code>为动态的<code>foo.cgi</code> ，而不为浏览器/用户所察觉。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>只须重写此URL为CGI-script ，以强制为可以作为CGI-script运行的正确的MIME类型。如此，对<code>/~quux/foo.html</code>的请求其实会执行<code>/~quux/foo.cgi</code> 。</p>

			<div class="example"><pre>
RewriteEngine  on
RewriteBase    /~quux/
RewriteRule    ^foo\.<strong>html</strong>$  foo.<strong>cgi</strong>  [T=<strong>application/x-httpd-cgi</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>传输过程中的内容协商</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>这是一个很难解的功能：动态生成的静态页面，即它应该作为静态页面发送(从文件系统中读出，然后直接发出去)，但是如果它丢失了，则由服务器动态生成。这样，可以静态地提供CGI生成的页面，除非有人(或者是一个cronjob)删除了这些静态页面，而且其内容可以得到更新。</p>
        </dd>

        <dt>方案:</dt>

        <dd>以下规则集实现了这个功能：

			<div class="example"><pre>
RewriteCond %{REQUEST_FILENAME}   <strong>!-s</strong>
RewriteRule ^page\.<strong>html</strong>$          page.<strong>cgi</strong>   [T=application/x-httpd-cgi,L]
</pre></div>

          <p>这样，如果<code>page.html</code>不存在或者文件大小为null ，则对<code>page.html</code>的请求会导致<code>page.cgi</code>的运行。其中奥妙在于<code>page.cgi</code>是一个将输出写入<code>page.html</code>的(同时也写入<code>STDOUT</code>)的常规的CGI脚本，执行完毕，服务器则将<code>page.html</code>的内容发出。如果网管需要强制更新其内容，只须删除<code>page.html</code>即可(通常由一个cronjob完成)。</p>
        </dd>
      </dl>

    

    <h3>自动更新的文档</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>建立一个复杂的页面，能够在用编辑器写了一个更新的版本时自动在浏览器上得到刷新，这不是很好吗？这可能吗？</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>这是可行的! 这需要综合利用MIME多成分、web服务器的NPH和<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>的URL操控特性。首先，建立一个新的URL特性：对在文件系统中更新时需要刷新的所有URL加上&quot;<code>:refresh</code>&quot; 。</p>

          <div class="example"><pre>
RewriteRule   ^(/[uge]/[^/]+/?.*):refresh  /internal/cgi/apache/nph-refresh?f=$1
</pre></div>

          <p>然后，修改URL</p>

<div class="example"><pre>
/u/foo/bar/page.html:refresh
</pre></div>

          <p>以内部地操控此URL</p>

<div class="example"><pre>
/internal/cgi/apache/nph-refresh?f=/u/foo/bar/page.html
</pre></div>

          <p>接着就是NPH-CGI脚本部分了。虽然，人们常说"将此作为一个练习留给读者"，但我还是给出答案了。</p>

          <div class="example"><pre>
#!/sw/bin/perl
##
##  nph-refresh -- NPH/CGI script for auto refreshing pages
##  Copyright (c) 1997 Ralf S. Engelschall, All Rights Reserved.
##
$| = 1;

#   split the QUERY_STRING variable
@pairs = split(/&amp;/, $ENV{'QUERY_STRING'});
foreach $pair (@pairs) {
    ($name, $value) = split(/=/, $pair);
    $name =~ tr/A-Z/a-z/;
    $name = 'QS_' . $name;
    $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
    eval "\$$name = \"$value\"";
}
$QS_s = 1 if ($QS_s eq '');
$QS_n = 3600 if ($QS_n eq '');
if ($QS_f eq '') {
    print "HTTP/1.0 200 OK\n";
    print "Content-type: text/html\n\n";
    print "&amp;lt;b&amp;gt;ERROR&amp;lt;/b&amp;gt;: No file given\n";
    exit(0);
}
if (! -f $QS_f) {
    print "HTTP/1.0 200 OK\n";
    print "Content-type: text/html\n\n";
    print "&amp;lt;b&amp;gt;ERROR&amp;lt;/b&amp;gt;: File $QS_f not found\n";
    exit(0);
}

sub print_http_headers_multipart_begin {
    print "HTTP/1.0 200 OK\n";
    $bound = "ThisRandomString12345";
    print "Content-type: multipart/x-mixed-replace;boundary=$bound\n";
    &amp;print_http_headers_multipart_next;
}

sub print_http_headers_multipart_next {
    print "\n--$bound\n";
}

sub print_http_headers_multipart_end {
    print "\n--$bound--\n";
}

sub displayhtml {
    local($buffer) = @_;
    $len = length($buffer);
    print "Content-type: text/html\n";
    print "Content-length: $len\n\n";
    print $buffer;
}

sub readfile {
    local($file) = @_;
    local(*FP, $size, $buffer, $bytes);
    ($x, $x, $x, $x, $x, $x, $x, $size) = stat($file);
    $size = sprintf("%d", $size);
    open(FP, "&amp;lt;$file");
    $bytes = sysread(FP, $buffer, $size);
    close(FP);
    return $buffer;
}

$buffer = &amp;readfile($QS_f);
&amp;print_http_headers_multipart_begin;
&amp;displayhtml($buffer);

sub mystat {
    local($file) = $_[0];
    local($time);

    ($x, $x, $x, $x, $x, $x, $x, $x, $x, $mtime) = stat($file);
    return $mtime;
}

$mtimeL = &amp;mystat($QS_f);
$mtime = $mtime;
for ($n = 0; $n &amp;lt; $QS_n; $n++) {
    while (1) {
        $mtime = &amp;mystat($QS_f);
        if ($mtime ne $mtimeL) {
            $mtimeL = $mtime;
            sleep(2);
            $buffer = &amp;readfile($QS_f);
            &amp;print_http_headers_multipart_next;
            &amp;displayhtml($buffer);
            sleep(5);
            $mtimeL = &amp;mystat($QS_f);
            last;
        }
        sleep($QS_s);
    }
}

&amp;print_http_headers_multipart_end;

exit(0);

##EOF##
</pre></div>
        </dd>
      </dl>

    

    <h3>大型虚拟主机</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>Apache的<code class="directive"><a href="../mod/core.html#&lt;virtualhost&gt;">&lt;VirtualHost&gt;</a></code>功能很强，在有几十个虚拟主机的情况下运行得很好，但是如果你是ISP，需要提供几百个虚拟主机，那么这就不是一个最佳的选择了。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>为此，需要用<dfn>代理吞吐(Proxy Throughput)</dfn>功能(flag <code>[P]</code>)映射远程页面甚至整个远程网络区域到自己的名称空间：</p>

<div class="example"><pre>
##
##  vhost.map
##
www.vhost1.dom:80  /path/to/docroot/vhost1
www.vhost2.dom:80  /path/to/docroot/vhost2
     :
www.vhostN.dom:80  /path/to/docroot/vhostN
</pre></div>

<div class="example"><pre>
##
##  httpd.conf
##
    :
#   use the canonical hostname on redirects, etc.
UseCanonicalName on

    :
#   add the virtual host in front of the CLF-format
CustomLog  /path/to/access_log  "%{VHOST}e %h %l %u %t \"%r\" %&gt;s %b"
    :

#   enable the rewriting engine in the main server
RewriteEngine on

#   define two maps: one for fixing the URL and one which defines
#   the available virtual hosts with their corresponding
#   DocumentRoot.
RewriteMap    lowercase    int:tolower
RewriteMap    vhost        txt:/path/to/vhost.map

#   Now do the actual virtual host mapping
#   via a huge and complicated single rule:
#
#   1. make sure we don't map for common locations
RewriteCond   %{REQUEST_URL}  !^/commonurl1/.*
RewriteCond   %{REQUEST_URL}  !^/commonurl2/.*
    :
RewriteCond   %{REQUEST_URL}  !^/commonurlN/.*
#
#   2. make sure we have a Host header, because
#      currently our approach only supports
#      virtual hosting through this header
RewriteCond   %{HTTP_HOST}  !^$
#
#   3. lowercase the hostname
RewriteCond   ${lowercase:%{HTTP_HOST}|NONE}  ^(.+)$
#
#   4. lookup this hostname in vhost.map and
#      remember it only when it is a path
#      (and not "NONE" from above)
RewriteCond   ${vhost:%1}  ^(/.*)$
#
#   5. finally we can map the URL to its docroot location
#      and remember the virtual host for logging puposes
RewriteRule   ^/(.*)$   %1/$1  [E=VHOST:${lowercase:%{HTTP_HOST}}]
    :
</pre></div>
        </dd>
      </dl>
</div>
<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="access" id="access">对访问的限制</a></h2>


    

    <h3>阻止Robots</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>如何阻止一个完全匿名的robot取得特定网络区域的页面？一个<code>/robots.txt</code>文件可以包含若干"robot排除协议"的行，但不足以阻止此类robot。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>可以用一个规则集以拒绝对网络区域<code>/~quux/foo/arc/</code>(对一个很深的目录区域进行列表可能会使服务器产生很大的负载)的访问。还必须确保仅阻止特定的robot，就是说，仅仅阻止robot访问主机是不够的，这样会同时也阻止了用户访问该主机。为此，就需要对HTTP头的User-Agent信息作匹配。</p>

<div class="example"><pre>
RewriteCond %{HTTP_USER_AGENT}   ^<strong>NameOfBadRobot</strong>.*
RewriteCond %{REMOTE_ADDR}       ^<strong>123\.45\.67\.[8-9]</strong>$
RewriteRule ^<strong>/~quux/foo/arc/</strong>.+   -   [<strong>F</strong>]
</pre></div>
        </dd>
      </dl>

    

    <h3>阻止内嵌的图片</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>假设，<code>http://www.quux-corp.de/~quux/</code>有一些内嵌图片的页面，这些图片很好，所以就有人用超链连到他们自己的页面中了。由于这样徒然增加了我们的服务器的流量，因此，我们不愿意这种事情发生。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>虽然，我们不能100%地保护这些图片不被写入别人的页面，但至少可以对发出HTTP Referer头的浏览器加以限制。</p>

<div class="example"><pre>
RewriteCond %{HTTP_REFERER} <strong>!^$</strong>
RewriteCond %{HTTP_REFERER} !^http://www.quux-corp.de/~quux/.*$ [NC]
RewriteRule <strong>.*\.gif$</strong>        -                                    [F]
</pre></div>

<div class="example"><pre>
RewriteCond %{HTTP_REFERER}         !^$
RewriteCond %{HTTP_REFERER}         !.*/foo-with-gif\.html$
RewriteRule <strong>^inlined-in-foo\.gif$</strong>   -                        [F]
</pre></div>
        </dd>
      </dl>

    

    <h3>对主机的拒绝</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>如何拒绝一批外部列表中的主机对我们服务器的使用？</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <div class="example"><pre>
RewriteEngine on
RewriteMap    hosts-deny  txt:/path/to/hosts.deny
RewriteCond   ${hosts-deny:%{REMOTE_HOST}|NOT-FOUND} !=NOT-FOUND [OR]
RewriteCond   ${hosts-deny:%{REMOTE_ADDR}|NOT-FOUND} !=NOT-FOUND
RewriteRule   ^/.*  -  [F]
</pre></div>
</dd>
      </dl>

    

    <h3>对代理的拒绝</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>如何拒绝某个主机或者来自特定主机的用户使用Apache代理？</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>首先，要确保Apache web服务器在编译时配置文件中<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>在<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>的下面！使它在<code class="module"><a href="../mod/mod_proxy.html">mod_proxy</a></code>之前被调用。然后，如下拒绝某个主机...</p>

			<div class="example"><pre>
RewriteCond %{REMOTE_HOST} <strong>^badhost\.mydomain\.com$</strong>
RewriteRule !^http://[^/.]\.mydomain.com.*  - [F]
</pre></div>

          <p>...如下拒绝user@host-dependent:</p>

<div class="example"><pre>
RewriteCond %{REMOTE_IDENT}@%{REMOTE_HOST}  <strong>^badguy@badhost\.mydomain\.com$</strong>
RewriteRule !^http://[^/.]\.mydomain.com.*  - [F]
</pre></div>
        </dd>
  </dl>

    

    <h3>特殊的认证</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>有时候，会需要一种非常特殊的认证，即对一组明确指定的用户，允许其访问，而没有(在使用<code class="module"><a href="../mod/mod_access.html">mod_access</a></code>的基本认证方法时可能会出现的)任何提示。</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>可是使用一个重写条件列表来排除所有的朋友：</p>

<div class="example"><pre>
RewriteCond %{REMOTE_IDENT}@%{REMOTE_HOST} <strong>!^friend1@client1.quux-corp\.com$</strong>
RewriteCond %{REMOTE_IDENT}@%{REMOTE_HOST} <strong>!^friend2</strong>@client2.quux-corp\.com$
RewriteCond %{REMOTE_IDENT}@%{REMOTE_HOST} <strong>!^friend3</strong>@client3.quux-corp\.com$
RewriteRule ^/~quux/only-for-friends/      -                                 [F]
</pre></div>
        </dd>
      </dl>

    

    <h3>基于提交者(Referer)的反射器</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>如何配置一个基于HTTP头"Referer"的反射器以反射到任意数量的提交页面?</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>使用这个很巧妙的规则集...</p>

          <div class="example"><pre>
RewriteMap  deflector txt:/path/to/deflector.map

RewriteCond %{HTTP_REFERER} !=""
RewriteCond ${deflector:%{HTTP_REFERER}} ^-$
RewriteRule ^.* %{HTTP_REFERER} [R,L]

RewriteCond %{HTTP_REFERER} !=""
RewriteCond ${deflector:%{HTTP_REFERER}|NOT-FOUND} !=NOT-FOUND
RewriteRule ^.* ${deflector:%{HTTP_REFERER}} [R,L]
</pre></div>

          <p>... 并结合对应的重写映射地图:</p>

          <div class="example"><pre>
##
##  deflector.map
##

http://www.badguys.com/bad/index.html    -
http://www.badguys.com/bad/index2.html   -
http://www.badguys.com/bad/index3.html   http://somewhere.com/
</pre></div>

          <p>它可以自动将请求(在映射地图中指定了"<code>-</code>"值的时候)反射回其提交页面，或者(在映射地图中URL有第二个参数时)反射到一个特定的URL。</p>
        </dd>
      </dl>
</div>

<div class="top"><a href="#page-header"><img alt="top" src="../images/up.gif" /></a></div>
<div class="section">
<h2><a name="other" id="other">其他</a></h2>


    

    <h3>外部重写引擎</h3>

      

      <dl>
        <dt>说明:</dt>

        <dd>
          <p>一个常见的问题是如何解决似乎无法用<code class="module"><a href="../mod/mod_rewrite.html">mod_rewrite</a></code>解决的FOO/BAR/QUUX/之类的问题？</p>
        </dd>

        <dt>方案:</dt>

        <dd>
          <p>可以使用一个与<code class="directive"><a href="../mod/mod_rewrite.html#rewritemap">RewriteMap</a></code>功能相同的外部<code class="directive"><a href="../mod/mod_rewrite.html#rewritemap">RewriteMap</a></code>程序，一旦它在Apache启动时被执行，则从<code>STDIN</code>接收被请求的URL ，并将处理过(通常是重写过的)的URL(以相同顺序)在<code>STDOUT</code>输出。</p>

			<div class="example"><pre>
RewriteEngine on
RewriteMap    quux-map       <strong>prg:</strong>/path/to/map.quux.pl
RewriteRule   ^/~quux/(.*)$  /~quux/<strong>${quux-map:$1}</strong>
</pre></div>

<div class="example"><pre>
#!/path/to/perl

#   disable buffered I/O which would lead
#   to deadloops for the Apache server
$| = 1;

#   read URLs one per line from stdin and
#   generate substitution URL on stdout
while (&lt;&gt;) {
    s|^foo/|bar/|;
    print $_;
}
</pre></div>

          <p>这是一个作演示的例子，只是把所有的URL <code>/~quux/foo/...</code> 重写为 <code>/~quux/bar/...</code> ，而事实上，可以把它修改以获得任何你需要的功能。但是要注意，虽然一般用户都可以<strong>使用</strong>，可是只有系统管理员才可以<strong>定义</strong>这样的地图。</p>
        </dd>
      </dl>
</div>
</div>
<div id="footer">
<p class="apache">本文允许自由使用、分发、转载，但必须保留译者署名；详见：<a href="../translator_announcement.html#announcement">译者声明</a>。</p>
<p class="menu"><a href="../mod/index.html">模块索引</a> | <a href="../mod/directives.html">指令索引</a> | <a href="../faq/index.html">常见问题</a> | <a href="../glossary.html">词汇表</a> | <a href="../sitemap.html">站点导航</a></p></div>
</body></html>